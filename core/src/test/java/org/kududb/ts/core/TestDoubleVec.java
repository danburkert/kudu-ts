package org.kududb.ts.core;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.SortedSet;
import java.util.TreeSet;

import org.junit.Test;

/*
 * DO NOT EDIT
 *
 * Autogenerated from src/templates/TestVec.java using the
 * src/templates/build script.
 */

public class TestDoubleVec {
  private static final Random RAND = new Random();

  private void assertPrimitiveEquals(double a, double b) {
    if (a != b) throw new AssertionError(String.format("%s != %s", a, b));
  }

  private List<Double> random() {
    return random(RAND.nextInt(1024));
  }

  private List<Double> random(int len) {
    List<Double> list = new ArrayList<>();
    for (int i = 0; i < len; i++) {
      list.add((double) RAND.nextInt(i + 1));
    }
    return Collections.unmodifiableList(list);
  }

  public void checkDoubleVec(List<Double> vals) {
    DoubleVec vec = DoubleVec.create();
    assertEquals(0, vec.len());

    // push
    for (double i : vals) {
      vec.push(i);
    }
    assertEquals(vals, vec.asList());

    // toString
    assertEquals(vals.toString(), vec.toString());

    // clone, equals
    DoubleVec copy = vec.clone();
    assertEquals(copy, vec);

    // truncate
    copy.truncate(vec.len() + 1);
    assertEquals(vals, copy.asList());
    vec.truncate(copy.len());
    assertEquals(vals, copy.asList());
    copy.truncate(vals.size() / 2);
    assertEquals(vals.subList(0, vals.size() / 2), copy.asList());

    // reserve
    int unused = copy.capacity() - copy.len();

    copy.reserve(unused);
    assertEquals(vec.capacity(), copy.capacity());

    copy.reserve(unused + 1);
    assertTrue(copy.capacity() > vec.capacity());

    copy.truncate(0);
    assertEquals(0, copy.len());

    // shrinkToFit
    copy.shrinkToFit();
    assertEquals(0, copy.capacity());
    vec.shrinkToFit();
    assertEquals(vec.len(), vec.capacity());

    // sort
    DoubleVec sorted = vec.clone();
    sorted.sort();
    List<Double> sortedInts = new ArrayList<>(vals);
    Collections.sort(sortedInts);
    assertEquals(sortedInts, sorted.asList());

    // intersect
    for (int i = 0; i < 100; i++) {
      List<Double> rand = random(i);

      DoubleVec a = DoubleVec.create();
      DoubleVec b = DoubleVec.create();
      for (double j : vals) a.push(j);
      for (double j : rand) b.push(j);
      a.sort();
      b.sort();

      DoubleVec left = a.clone();
      DoubleVec right = b.clone();

      left.intersect(b);
      right.intersect(a);

      SortedSet<Double> expected =
          ImmutableSortedSet.copyOf(Sets.intersection(ImmutableSet.copyOf(vals),
                                                      ImmutableSet.copyOf(rand)));

      // There's no easy way to get a set intersection that preserves duplicates,
      // so we dedup. Intersections with duplicates are tested below.
      left.dedup();
      right.dedup();

      assertEquals(left, right);
      assertEquals(ImmutableList.copyOf(expected), left.asList());
    }

    // dedup
    sorted.dedup();
    assertEquals(ImmutableList.copyOf(new TreeSet<>(vals)), sorted.asList());

    // merge
    for (int i = 0; i < 100; i++) {
      List<Double> rand = random(i);

      DoubleVec a = DoubleVec.create();
      DoubleVec b = DoubleVec.create();
      for (double j : vals) a.push(j);
      for (double j : rand) b.push(j);
      a.sort();
      b.sort();

      DoubleVec left = a.clone();
      DoubleVec right = b.clone();

      left.merge(b);
      right.merge(a);

      List<Double> sortedRand = new ArrayList<>(rand);
      Collections.sort(sortedRand);
      Iterable<Double> expected = Iterables.mergeSorted(ImmutableList.of(sortedInts, sortedRand),
                                                        Ordering.natural());

      assertEquals(left, right);
      assertEquals(ImmutableList.copyOf(expected), left.asList());
    }

    // get
    for (int i = 0; i < vals.size(); i++) {
      assertPrimitiveEquals((double) vals.get(i), vec.get(i));
    }

    // set
    if (vec.len() > 0) {
      copy = vec.clone();
      int index = RAND.nextInt(vec.len());
      copy.set(index, index);
      List<Double> intsCopy = new ArrayList<>(vals);
      intsCopy.set(index, (double) index);
      assertEquals(intsCopy, copy.asList());
    }
  }

  @Test
  public void testDoubleVec() throws Exception {
    checkDoubleVec(random(0));
    checkDoubleVec(random(1));
    checkDoubleVec(random(2));
    checkDoubleVec(random(3));
    checkDoubleVec(random(DoubleVec.DEFAULT_CAPACITY - 2));
    checkDoubleVec(random(DoubleVec.DEFAULT_CAPACITY - 1));
    checkDoubleVec(random(DoubleVec.DEFAULT_CAPACITY));
    checkDoubleVec(random(DoubleVec.DEFAULT_CAPACITY + 1));
    checkDoubleVec(random(DoubleVec.DEFAULT_CAPACITY + 2));

    for (int i = 0; i < 100; i++) {
      checkDoubleVec(random());
    }
  }

  @Test
  public void testIntersectionWithDuplicates() throws Exception {
    DoubleVec a = DoubleVec.wrap(new double[] { 0, 1, 1, });
    DoubleVec b = DoubleVec.wrap(new double[] { 1, 1, 3, });

    DoubleVec left = a.clone();
    left.intersect(b);

    assertEquals(2, left.len());

    DoubleVec right = b.clone();
    right.intersect(a);

    assertEquals(left, right);
    assertEquals(ImmutableList.of((double) 1, (double) 1), left.asList());
  }
}
