package org.kududb.ts.core;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.SortedSet;
import java.util.TreeSet;

import org.junit.Test;

/*
 * DO NOT EDIT
 *
 * Autogenerated from src/templates/TestVec.java using the
 * src/templates/build script.
 */

public class Test{ShortType}Vec {
  private static final Random RAND = new Random();

  private void assertPrimitiveEquals({Primitive} a, {Primitive} b) {
    if (a != b) throw new AssertionError(String.format("%s != %s", a, b));
  }

  private List<{Type}> random() {
    return random(RAND.nextInt(1024));
  }

  private List<{Type}> random(int len) {
    List<{Type}> list = new ArrayList<>();
    for (int i = 0; i < len; i++) {
      list.add(({Primitive}) RAND.nextInt(i + 1));
    }
    return Collections.unmodifiableList(list);
  }

  public void check{ShortType}Vec(List<{Type}> vals) {
    {ShortType}Vec vec = {ShortType}Vec.create();
    assertEquals(0, vec.len());

    // push
    for ({Primitive} i : vals) {
      vec.push(i);
    }
    assertEquals(vals, vec.asList());

    // toString
    assertEquals(vals.toString(), vec.toString());

    // clone, equals
    {ShortType}Vec copy = vec.clone();
    assertEquals(copy, vec);

    // truncate
    copy.truncate(vec.len() + 1);
    assertEquals(vals, copy.asList());
    vec.truncate(copy.len());
    assertEquals(vals, copy.asList());
    copy.truncate(vals.size() / 2);
    assertEquals(vals.subList(0, vals.size() / 2), copy.asList());

    // reserve
    int unused = copy.capacity() - copy.len();

    copy.reserve(unused);
    assertEquals(vec.capacity(), copy.capacity());

    copy.reserve(unused + 1);
    assertTrue(copy.capacity() > vec.capacity());

    copy.truncate(0);
    assertEquals(0, copy.len());

    // shrinkToFit
    copy.shrinkToFit();
    assertEquals(0, copy.capacity());
    vec.shrinkToFit();
    assertEquals(vec.len(), vec.capacity());

    // sort
    {ShortType}Vec sorted = vec.clone();
    sorted.sort();
    List<{Type}> sortedInts = new ArrayList<>(vals);
    Collections.sort(sortedInts);
    assertEquals(sortedInts, sorted.asList());

    // intersect
    for (int i = 0; i < 100; i++) {
      List<{Type}> rand = random(i);

      {ShortType}Vec a = {ShortType}Vec.create();
      {ShortType}Vec b = {ShortType}Vec.create();
      for ({Primitive} j : vals) a.push(j);
      for ({Primitive} j : rand) b.push(j);
      a.sort();
      b.sort();

      {ShortType}Vec left = a.clone();
      {ShortType}Vec right = b.clone();

      left.intersect(b);
      right.intersect(a);

      SortedSet<{Type}> expected =
          ImmutableSortedSet.copyOf(Sets.intersection(ImmutableSet.copyOf(vals),
                                                      ImmutableSet.copyOf(rand)));

      // There's no easy way to get a set intersection that preserves duplicates,
      // so we dedup. Intersections with duplicates are tested below.
      left.dedup();
      right.dedup();

      assertEquals(left, right);
      assertEquals(ImmutableList.copyOf(expected), left.asList());
    }

    // dedup
    sorted.dedup();
    assertEquals(ImmutableList.copyOf(new TreeSet<>(vals)), sorted.asList());

    // merge
    for (int i = 0; i < 100; i++) {
      List<{Type}> rand = random(i);

      {ShortType}Vec a = {ShortType}Vec.create();
      {ShortType}Vec b = {ShortType}Vec.create();
      for ({Primitive} j : vals) a.push(j);
      for ({Primitive} j : rand) b.push(j);
      a.sort();
      b.sort();

      {ShortType}Vec left = a.clone();
      {ShortType}Vec right = b.clone();

      left.merge(b);
      right.merge(a);

      List<{Type}> sortedRand = new ArrayList<>(rand);
      Collections.sort(sortedRand);
      Iterable<{Type}> expected = Iterables.mergeSorted(ImmutableList.of(sortedInts, sortedRand),
                                                        Ordering.natural());

      assertEquals(left, right);
      assertEquals(ImmutableList.copyOf(expected), left.asList());
    }

    // get
    for (int i = 0; i < vals.size(); i++) {
      assertPrimitiveEquals(({Primitive}) vals.get(i), vec.get(i));
    }

    // set
    if (vec.len() > 0) {
      copy = vec.clone();
      int index = RAND.nextInt(vec.len());
      copy.set(index, index);
      List<{Type}> intsCopy = new ArrayList<>(vals);
      intsCopy.set(index, ({Primitive}) index);
      assertEquals(intsCopy, copy.asList());
    }
  }

  @Test
  public void test{ShortType}Vec() throws Exception {
    check{ShortType}Vec(random(0));
    check{ShortType}Vec(random(1));
    check{ShortType}Vec(random(2));
    check{ShortType}Vec(random(3));
    check{ShortType}Vec(random({ShortType}Vec.DEFAULT_CAPACITY - 2));
    check{ShortType}Vec(random({ShortType}Vec.DEFAULT_CAPACITY - 1));
    check{ShortType}Vec(random({ShortType}Vec.DEFAULT_CAPACITY));
    check{ShortType}Vec(random({ShortType}Vec.DEFAULT_CAPACITY + 1));
    check{ShortType}Vec(random({ShortType}Vec.DEFAULT_CAPACITY + 2));

    for (int i = 0; i < 100; i++) {
      check{ShortType}Vec(random());
    }
  }

  @Test
  public void testIntersectionWithDuplicates() throws Exception {
    {ShortType}Vec a = {ShortType}Vec.wrap(new {Primitive}[] { 0, 1, 1, });
    {ShortType}Vec b = {ShortType}Vec.wrap(new {Primitive}[] { 1, 1, 3, });

    {ShortType}Vec left = a.clone();
    left.intersect(b);

    assertEquals(2, left.len());

    {ShortType}Vec right = b.clone();
    right.intersect(a);

    assertEquals(left, right);
    assertEquals(ImmutableList.of(({Primitive}) 1, ({Primitive}) 1), left.asList());
  }
}
